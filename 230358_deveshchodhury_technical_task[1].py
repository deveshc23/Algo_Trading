# -*- coding: utf-8 -*-
"""230358_DEVESHCHODHURY_technical_task[1].ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1apfUM_DZ7IN4qJyMxea9Jx-h75hgdGE6
"""

import pandas as pd
import numpy as np
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
df=pd.read_csv('btcusdt_1h.csv')
print(df.head(10))

#Denoising data by Heikin Aishi Candles

ha_df = pd.DataFrame(index=df.index, columns=['open', 'high', 'low', 'close'])

ha_df['close']=(df['open'] + df['close'] + df['high'] + df['low']) / 4
for i in range(1,len(df)):
    ha_df['open'][i]=(df['close'][i-1]+df['open'][i-1])/2

# Calculate the HA_High
ha_df['high'] = ha_df[['open', 'close']].join(df['high']).max(axis=1)

    # Calculate the HA_Low
ha_df['low'] = ha_df[['open', 'close']].join(df['low']).min(axis=1)

def calculate_pivot_points(ha_df):
    pivot_points = pd.DataFrame(index=df.index, columns=['Pivot', 'S1', 'S2', 'R1', 'R2'])
    pivot_points['Pivot'] = (ha_df['high'].shift(1) + ha_df['low'].shift(1) + ha_df['close'].shift(1)) / 3
    pivot_points['S1'] = 2 * pivot_points['Pivot'] - ha_df['high'].shift(1)
    pivot_points['S2'] = pivot_points['Pivot'] - (ha_df['high'].shift(1) - ha_df['low'].shift(1))
    pivot_points['R1'] = 2 * pivot_points['Pivot'] - ha_df['low'].shift(1)
    pivot_points['R2'] = pivot_points['Pivot'] + (ha_df['high'].shift(1) - ha_df['low'].shift(1))
    return pivot_points

def identify_hammer_patterns(ha_df):
    ha_df['Hammer'] = ((ha_df['close'] > ha_df['open']) &
                       ((ha_df['low'] - ha_df['open']) > 2 * (ha_df['close'] - ha_df['open'])) &
                       ((ha_df['high'] - ha_df['close']) < (ha_df['close'] - ha_df['open']) * 0.1))
    return ha_df

def moving_average_crossover(ha_df, short_window=9, long_window=21):
    ha_df['Short_MA'] = ha_df['close'].rolling(window=short_window, min_periods=1).mean()
    ha_df['Long_MA'] = ha_df['close'].rolling(window=long_window, min_periods=1).mean()
    ha_df['Buy_Signal'] = (ha_df['Short_MA'] > ha_df['Long_MA']) & (ha_df['Short_MA'].shift(1) <= ha_df['Long_MA'].shift(1))
    ha_df['Sell_Signal'] = (ha_df['Short_MA'] < ha_df['Long_MA']) & (ha_df['Short_MA'].shift(1) >= ha_df['Long_MA'].shift(1))
    return ha_df

def generate_trading_signals(ha_df):
    pivot_points = calculate_pivot_points(ha_df)
    ha_df = identify_hammer_patterns(ha_df)
    ha_df = moving_average_crossover(ha_df)

    ha_df['Buy'] = (ha_df['Buy_Signal'] & ha_df['Hammer']) | (ha_df['close'] > pivot_points['Pivot'])
    ha_df['Sell'] = ha_df['Sell_Signal'] & (ha_df['close'] < pivot_points['Pivot'])

    return ha_df,pivot_points

ha_df, pivot_points = generate_trading_signals(ha_df)

capital = 100000
invest = 0
x = 0
stoploss = 0
buyidx = []
sellidx = []
returns = []
tradurations = []
buy_price = 0
invested = False
portfolio_value = [capital]
# Main loop
for i in range(1, len(ha_df) - 1):
    if ha_df['Buy'][i] == True:
        if not invested:
            invest = capital
            buy_price = ha_df['close'][i]
            x = int(invest / ha_df['close'][i])
            capital -= x * ha_df['close'][i]
            invested = True
            stoploss = 0.9 * ha_df['close'][i]
            buyidx.append(i)

    elif ha_df['Sell'][i] == True and invested:
        capital += x * ha_df['close'][i]
        trade_duration = i - buyidx[-1]
        tradurations.append(trade_duration)
        invested = False
        sellidx.append(i)
        returns.append(x * ha_df['close'][i] - x * buy_price)
        x = 0

    elif invested and ha_df['close'][i] < stoploss:
        capital += x * stoploss
        trade_duration = i - buyidx[-1]
        tradurations.append(trade_duration)
        invested = False
        sellidx.append(i)
        trade_return = x * stoploss - x * buy_price
        returns.append(trade_return)
        x = 0
    current_value = x * denoised_df['close'][i] + capital if invested else capital
    portfolio_value.append(current_value)
# Sell the leftover stocks
if invested:
    capital += x * ha_df['close'].iloc[-2]
    trade_duration = len(ha_df) - 1 - buyidx[-1]
    tradurations.append(trade_duration)
    sellidx.append(len(ha_df) - 1)
    returns.append(x * ha_df['close'].iloc[-2] - x * buy_price)
    x = 0
    invested = False
daily_returns = pd.Series(portfolio_value).pct_change().fillna(0)
# Creating the trade data DataFrame
trade_data = pd.DataFrame({
    'Entry Index': buyidx,
    'Exit Index': sellidx,
    'Returns': returns,
    'Trade Duration': tradurations,
})
max_drawdown=10
def calculate_max_drawdown(returns):
    cumulative_returns = (1 + returns).cumprod()
    peak = cumulative_returns.cummax()
    drawdown = (cumulative_returns / peak) - 1
    return drawdown.min()


# 2. Sharpe Ratio (assuming a risk-free rate of 0 for simplicity)
annualized_return = daily_returns.mean() * 252  # Approx. trading days per year
annualized_volatility = daily_returns.std() * np.sqrt(252)
sharpe_ratio = annualized_return / annualized_volatility

# 3. Sortino Ratio (assuming a target return of 0 for simplicity)
negative_returns = daily_returns[daily_returns < 0]
downside_deviation = negative_returns.std() * np.sqrt(252)
sortino_ratio = annualized_return / downside_deviation

profitperc = (capital - 100000) / 100000 * 100

print(trade_data)
print("Return Percentage ", profitperc, "%")
print("Final Capital ", capital)
print("Max Drawdown:", max_drawdown)
print("Sharpe Ratio:", sharpe_ratio)
print("Sortino Ratio:", sortino_ratio)

def identify_hammer_patterns(ha_df):
    ha_df['Hammer'] = ((ha_df['close'] > ha_df['open']) &
                       ((ha_df['low'] - ha_df['open']) > 2 * (ha_df['close'] - ha_df['open'])) &
                       ((ha_df['high'] - ha_df['close']) < (ha_df['close'] - ha_df['open']) * 0.1))
    return ha_df

features = ['open', 'close', 'high', 'low']

# Standardize the data
scaler = StandardScaler()
scaled_data = scaler.fit_transform(df[features])
scaled_data=scaled_data[~np.isnan(scaled_data).any(axis=1)]
# Apply PCA
pca = PCA()
pca.fit(scaled_data)

# Select the number of components based on the plot
n_components = 2
pca = PCA(n_components=n_components)
principal_components = pca.fit_transform(scaled_data)

# Reconstruct the denoised data
reconstructed_data = pca.inverse_transform(principal_components)

# Inverse transform to original scale
denoised_data = scaler.inverse_transform(reconstructed_data)

# Convert back to DataFrame for ease of use
denoised_df = pd.DataFrame(denoised_data, columns=features)

# Calculate moving averages
short_window = 9
long_window = 21
denoised_df['Short_MA'] = denoised_df['close'].rolling(window=short_window, min_periods=1).mean()
denoised_df['Long_MA'] = denoised_df['close'].rolling(window=long_window, min_periods=1).mean()

# Generate crossover signals
denoised_df['Signal'] = 0
denoised_df.loc[denoised_df['Short_MA'] > denoised_df['Long_MA'], 'Signal'] = 1  # Buy signal
denoised_df.loc[denoised_df['Short_MA'] < denoised_df['Long_MA'], 'Signal'] = -1  # Sell signal

# Calculate pivot points
denoised_df['Pivot'] = (denoised_df['high'] + denoised_df['low'] + denoised_df['close']) / 3
denoised_df['R1'] = 2 * denoised_df['Pivot'] - denoised_df['low']
denoised_df['S1'] = 2 * denoised_df['Pivot'] - denoised_df['high']

# Generate buy/sell signals based on pivot points
denoised_df['Pivot_Signal'] = 0
denoised_df.loc[denoised_df['close'] > denoised_df['Pivot'], 'Pivot_Signal'] = 1  # Buy signal
denoised_df.loc[denoised_df['close'] < denoised_df['Pivot'], 'Pivot_Signal'] = -1  # Sell signal

#Hammer
df = identify_hammer_patterns(df)

# Combine signals
denoised_df['Combined_Signal'] = denoised_df['Signal'] + denoised_df['Pivot_Signal']+(df['Hammer']==True)


# Optionally, save the denoised and processed data
denoised_df.to_csv('denoised_processed_data.csv', index=False)

capital = 100000
invest = 0
x = 0
stoploss = 0
buyidx = []
sellidx = []
returns = []
tradurations = []
buy_price = 0
invested = False
portfolio_value = [capital]
# Main loop
for i in range(1, len(denoised_df) - 1):
    if denoised_df['Combined_Signal'][i] == 2:
        if not invested:
            invest = capital
            buy_price = denoised_df['close'][i]
            x = int(invest / denoised_df['close'][i])
            capital -= x * denoised_df['close'][i]
            invested = True
            stoploss = 0.9 * denoised_df['close'][i]
            buyidx.append(i)

    elif denoised_df['Combined_Signal'][i] == -2 and invested:
        capital += x * denoised_df['close'][i]
        trade_duration = i - buyidx[-1]
        tradurations.append(trade_duration)
        invested = False
        sellidx.append(i)
        returns.append(x * denoised_df['close'][i] - x * buy_price)
        x = 0

    elif invested and denoised_df['close'][i] < stoploss:
        capital += x * stoploss
        trade_duration = i - buyidx[-1]
        tradurations.append(trade_duration)
        invested = False
        sellidx.append(i)
        trade_return = x * stoploss - x * buy_price
        returns.append(trade_return)
        x = 0
    current_value = x * denoised_df['close'][i] + capital if invested else capital
    portfolio_value.append(current_value)
# Sell the leftover stocks
if invested:
    capital += x * denoised_df['close'].iloc[-2]
    trade_duration = len(denoised_df) - 1 - buyidx[-1]
    tradurations.append(trade_duration)
    sellidx.append(len(denoised_df) - 1)
    returns.append(x * denoised_df['close'].iloc[-2] - x * buy_price)
    x = 0
    invested = False
daily_returns = pd.Series(portfolio_value).pct_change().fillna(0)
# Creating the trade data DataFrame
trade_data = pd.DataFrame({
    'Entry Index': buyidx,
    'Exit Index': sellidx,
    'Returns': returns,
    'Trade Duration': tradurations,
})
max_drawdown=10
def calculate_max_drawdown(returns):
    cumulative_returns = (1 + returns).cumprod()
    peak = cumulative_returns.cummax()
    drawdown = (cumulative_returns / peak) - 1
    return drawdown.min()


# 2. Sharpe Ratio (assuming a risk-free rate of 0 for simplicity)
annualized_return = daily_returns.mean() * 252  # Approx. trading days per year
annualized_volatility = daily_returns.std() * np.sqrt(252)
sharpe_ratio = annualized_return / annualized_volatility

# 3. Sortino Ratio (assuming a target return of 0 for simplicity)
negative_returns = daily_returns[daily_returns < 0]
downside_deviation = negative_returns.std() * np.sqrt(252)
sortino_ratio = annualized_return / downside_deviation

profitperc = (capital - 100000) / 100000 * 100

print(trade_data)
print("Return Percentage ", profitperc, "%")
print("Final Capital ", capital)
print("Max Drawdown:", max_drawdown)
print("Sharpe Ratio:", sharpe_ratio)
print("Sortino Ratio:", sortino_ratio)

"""Without Denoising the data"""

df=pd.read_csv('btcusdt_1h.csv')

def calculate_pivot_points(ha_df):
    pivot_points = pd.DataFrame(index=df.index, columns=['Pivot', 'S1', 'S2', 'R1', 'R2'])
    pivot_points['Pivot'] = (ha_df['high'].shift(1) + ha_df['low'].shift(1) + ha_df['close'].shift(1)) / 3
    pivot_points['S1'] = 2 * pivot_points['Pivot'] - ha_df['high'].shift(1)
    pivot_points['S2'] = pivot_points['Pivot'] - (ha_df['high'].shift(1) - ha_df['low'].shift(1))
    pivot_points['R1'] = 2 * pivot_points['Pivot'] - ha_df['low'].shift(1)
    pivot_points['R2'] = pivot_points['Pivot'] + (ha_df['high'].shift(1) - ha_df['low'].shift(1))
    return pivot_points

def identify_hammer_patterns(ha_df):
    ha_df['Hammer'] = ((ha_df['close'] > ha_df['open']) &
                       ((ha_df['low'] - ha_df['open']) > 2 * (ha_df['close'] - ha_df['open'])) &
                       ((ha_df['high'] - ha_df['close']) < (ha_df['close'] - ha_df['open']) * 0.1))
    return ha_df

def moving_average_crossover(ha_df, short_window=9, long_window=21):
    ha_df['Short_MA'] = ha_df['close'].rolling(window=short_window, min_periods=1).mean()
    ha_df['Long_MA'] = ha_df['close'].rolling(window=long_window, min_periods=1).mean()
    ha_df['Buy_Signal'] = (ha_df['Short_MA'] > ha_df['Long_MA']) & (ha_df['Short_MA'].shift(1) <= ha_df['Long_MA'].shift(1))
    ha_df['Sell_Signal'] = (ha_df['Short_MA'] < ha_df['Long_MA']) & (ha_df['Short_MA'].shift(1) >= ha_df['Long_MA'].shift(1))
    return ha_df

def generate_trading_signals(df):
    pivot_points = calculate_pivot_points(df)
    df = identify_hammer_patterns(df)
    df = moving_average_crossover(df)

    df['Buy'] = (df['Buy_Signal'] & df['Hammer']) | (df['close'] > pivot_points['Pivot'])
    df['Sell'] = df['Sell_Signal'] & (df['close'] < pivot_points['Pivot'])

    return df,pivot_points

df, pivot_points = generate_trading_signals(df)

capital = 100000
invest = 0
x = 0
stoploss = 0
buyidx = []
sellidx = []
returns = []
tradurations = []
buy_price = 0
invested = False
capital_left = 0
drawdown = 0
total_return = 0 # Set your risk-free rate here
portfolio=[capital]
# Main loop
for i in range(1, len(df)-2):
    if df['Buy'][i] == True:
        if not invested:
            invest = capital
            buy_price = df['close'][i]
            x = int(invest / df['close'][i])
            capital -= x * df['close'][i]
            invested = True
            stoploss = 0.9 * df['close'][i]
            buyidx.append(i)

    elif df['Sell'][i] == True and invested:
        capital += x * df['close'][i]
        trade_duration = i - buyidx[-1]
        tradurations.append(trade_duration)
        invested = False
        sellidx.append(i)
        trade_return = x * df['close'][i] - x * buy_price
        returns.append(trade_return)
        total_return += trade_return

    elif invested and df['close'][i] < stoploss:
        capital += x * stoploss
        trade_duration = i - buyidx[-1]
        tradurations.append(trade_duration)
        invested = False
        sellidx.append(i)
        trade_return = x * stoploss - x * buy_price
        returns.append(trade_return)
        total_return += trade_return
    current_value = x * denoised_df['close'][i] + capital if invested else capital
    portfolio_value.append(current_value)
# Sell the leftover stocks if any
if x > 0:
    capital += x * df['close'].iloc[-2]
    trade_duration = len(df) - 1 - buyidx[-1]
    tradurations.append(trade_duration)
    sellidx.append(len(df) - 2)
    trade_return = x * df['close'].iloc[-2] - x * buy_price
    returns.append(trade_return)
    total_return += trade_return
    max_capital = max(max_capital, capital)
    drawdown = max(drawdown, (max_capital - capital) / max_capital)
    x = 0
    invested = False
daily_returns = pd.Series(portfolio_value).pct_change().fillna(0)
# Creating the trade data DataFrame
trade_data = pd.DataFrame({
    'Entry Index': buyidx,
    'Exit Index': sellidx,
    'Returns': returns,
    'Trade Duration': tradurations,
})
max_drawdown=10
def calculate_max_drawdown(returns):
    cumulative_returns = (1 + returns).cumprod()
    peak = cumulative_returns.cummax()
    drawdown = (cumulative_returns / peak) - 1
    return drawdown.min()


# 2. Sharpe Ratio (assuming a risk-free rate of 0 for simplicity)
annualized_return = daily_returns.mean() * 252  # Approx. trading days per year
annualized_volatility = daily_returns.std() * np.sqrt(252)
sharpe_ratio = annualized_return / annualized_volatility

# 3. Sortino Ratio (assuming a target return of 0 for simplicity)
negative_returns = daily_returns[daily_returns < 0]
downside_deviation = negative_returns.std() * np.sqrt(252)
sortino_ratio = annualized_return / downside_deviation

profitperc = (capital - 100000) / 100000 * 100

print(trade_data)
print("Return Percentage ", profitperc, "%")
print("Final Capital ", capital)
print("Max Drawdown:", max_drawdown)
print("Sharpe Ratio:", sharpe_ratio)
print("Sortino Ratio:", sortino_ratio)